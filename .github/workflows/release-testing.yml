# Copyright (c) 2022-present New Relic Corporation. All rights reserved.
# SPDX-License-Identifier: Apache-2.0 

name: "release"

# Controls when the action will run.
# Workflow runs when manually triggered using the UI
# or API, or when code is pushed to main branch.
on:
  push:
    branches:
      - main
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      confirmation:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Are you sure you want to release?'
        type: boolean
        # Default value if no value is explicitly provided
        default: false
        # Input has to be provided for the workflow to run
        required: true

permissions:
  # In order to create the git tag, we must have write permissions.
  contents: write
  # This is important. Trusted Publishing requires this for the OIDC exchange.
  id-token: write


# A workflow run is made up of one or more jobs
# that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "greet"
  release:
    # The type of runner that the job will run on
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        node-version: [24.x]
        os: [ubuntu-latest]

    # Steps represent a sequence of tasks that
    # will be executed as part of the job
    steps:
      - name: Checkout the release branch for testing
        uses: actions/checkout@v2
        with:
          ref:  main
          fetch-depth: 0
          # token: ${{ secrets.API_CLI_TOKEN }}
          # path: newrelic-actions  # This might have to exist within ".github"

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v5 # https://github.com/actions/setup-node
        with:
          node-version: ${{ matrix.node-version }}
          registry-url: 'https://registry.npmjs.org'

      - name: Check if version was updated in package.json
        id: version_check
        run: |
          CURRENT_VERSION=$(jq -r '.version' package.json)
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Get the previous commit's package.json version
          git show HEAD~1:package.json > prev-package.json 2>/dev/null || echo '{"version":"0.0.0"}' > prev-package.json
          PREVIOUS_VERSION=$(jq -r '.version' prev-package.json)
          echo "previous_version=$PREVIOUS_VERSION" >> $GITHUB_OUTPUT

          if [ "$CURRENT_VERSION" != "$PREVIOUS_VERSION" ]; then
            echo "version_changed=true" >> $GITHUB_OUTPUT
            echo "Version changed from $PREVIOUS_VERSION to $CURRENT_VERSION"
          else
            echo "version_changed=false" >> $GITHUB_OUTPUT
            echo "Version unchanged: $CURRENT_VERSION"
          fi

          rm -f prev-package.json

      - name: Setup GitHub Credentials
        if: steps.version_check.outputs.version_changed == 'false' && github.event_name == 'push'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Auto-bump version if not changed
        id: auto_bump
        if: steps.version_check.outputs.version_changed == 'false' && github.event_name == 'push'
        run: |
          CURRENT_VERSION="${{ steps.version_check.outputs.current_version }}"
          echo "Current version: $CURRENT_VERSION"

          # Parse version
          major=$(echo "$CURRENT_VERSION" | cut -d. -f1)
          minor=$(echo "$CURRENT_VERSION" | cut -d. -f2)
          patch=$(echo "$CURRENT_VERSION" | cut -d. -f3)

          # Check commit message for version bump type
          COMMIT_MSG=$(git log -1 --pretty=%B)

          if echo "$COMMIT_MSG" | grep -qiE "^(feat|feature):"; then
            # Minor version bump for features
            NEW_MINOR=$((minor + 1))
            NEW_VERSION="$major.$NEW_MINOR.0"
            BUMP_TYPE="minor (feature)"
          elif echo "$COMMIT_MSG" | grep -qiE "^(fix|bugfix):"; then
            # Patch version bump for fixes
            NEW_PATCH=$((patch + 1))
            NEW_VERSION="$major.$minor.$NEW_PATCH"
            BUMP_TYPE="patch (fix)"
          elif echo "$COMMIT_MSG" | grep -qiE "^(breaking|major):"; then
            # Major version bump for breaking changes
            NEW_MAJOR=$((major + 1))
            NEW_VERSION="$NEW_MAJOR.0.0"
            BUMP_TYPE="major (breaking)"
          else
            # Default to patch bump
            NEW_PATCH=$((patch + 1))
            NEW_VERSION="$major.$minor.$NEW_PATCH"
            BUMP_TYPE="patch (default)"
          fi

          echo "Bumping version from $CURRENT_VERSION to $NEW_VERSION ($BUMP_TYPE)"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

          # Update package.json
          jq --arg version "$NEW_VERSION" '.version = $version' package.json > package-tmp.json && mv package-tmp.json package.json

          # Update CHANGELOG.md
          TODAY=$(date +%Y-%m-%d)
          sed -i "2i\\## $NEW_VERSION ($TODAY)\n\n- Auto-release from commit: ${COMMIT_MSG}\n\n" CHANGELOG.md

          # Commit and push changes
          git add package.json CHANGELOG.md
          git commit -m "chore: bump version to $NEW_VERSION [skip ci]

          - Auto-bumped version based on commit type
          - Updated CHANGELOG.md

          ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

          Co-Authored-By: Claude <noreply@anthropic.com>"
          git push origin main

      - name: Wait for version update commit
        if: steps.version_check.outputs.version_changed == 'false' && github.event_name == 'push'
        run: |
          echo "Version was auto-bumped. Exiting to allow the new commit to trigger a fresh workflow run."
          exit 0

      - name: create tag
        if: steps.version_check.outputs.version_changed == 'true' || github.event_name == 'workflow_dispatch'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git tag v$(jq -r '.version' package.json)
          git push --tags
          
      - name: Install Dependencies
        if: steps.version_check.outputs.version_changed == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          if [ -e yarn.lock ]; then
          yarn install --frozen-lockfile
          elif [ -e package-lock.json ]; then
          npm ci
          else
          npm i
          fi

      - name: Run all test cases
        if: steps.version_check.outputs.version_changed == 'true' || github.event_name == 'workflow_dispatch'
        run: npm run test

      - name: create release
        if: steps.version_check.outputs.version_changed == 'true' || github.event_name == 'workflow_dispatch'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create v$(jq -r '.version' package.json) --generate-notes

      - name: Publish as NPM package on new relic account(we need npm secret from new relic account)
        if: steps.version_check.outputs.version_changed == 'true' || github.event_name == 'workflow_dispatch'
        run: npm publish

      - name: Capture logs if previous failure
        if: ${{ failure() }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ github.workflow }}-npm-logs
          path: |
            /home/runner/.npm/_logs/
      # Check ENV variables
      - name: Check environmental variables
        if: ${{ always() }}
        run: printenv | sort -f
